# secrets-manager

![Javascript](https://github.com/Keeper-Security/secrets-manager/actions/workflows/test.js.yml/badge.svg)

Monorepo for secrets manager sdk's and tools



For structure, using guidance from https://medium.com/interstellar/monorepo-e1847cbd6800

To test ci locally, install https://github.com/nektos/act and run ./test_ci.sh

### Overview

Secrets Manager is an API hosted by Keeper, and a set of SDK's that consume the API.
It is designed to allow sharing the secrets (passwords, tokens, keys, etc.) with various devices, 
physical and virtual, in a zero-knowledge way. A secret is either a single Keeper record, or a Keeper Shared Folder
containing a set of records.

Secrets Manager uses password-less authentication, relying on digital signature to authenticate clients.
The client's private key is generated by the SDK, and must be stored securely by the client. 
Client can generate one or multiple private keys, each key would give the client access to a single secret 
(Keeper Record or Keeper Shared Folder) 

###API

All API calls take a key value storage implementation as a parameter.
The key value storage is used to persist the data generated by the SDK (keys, cached data, etc.)
The key value storage implementation needs to be secure - keys compromise will allow an attacker to 
access the secret shared with the device.

####getSecrets
Takes a key value storage implementation and returns Keeper Secret as JSON object. 
It is a client responsibility to parse the JSON and use the content as intended. 

###Authentication protocol

Keeper identifies the client in two different ways:

- Initially(first access), by a _temporary_ **Binding Access Token**, which is a hash of the _temporary_ **Binding Access Key**. 
  Binding Access Key is a random key, used to encrypt the Keeper Record key or Keeper Shared Folder key.
  Binding Access Key is sent to the client using mechanisms that do not involve Keeper, 
  to keep zero knowledge. When performing the first access call, the client sends to Keeper the public key of the
  private key that was generated by the client.
- Subsequently, by a digital signature using the private key the client has generated.

####Detailed steps:  

1.  Secret owner generates a random 256-bit **Binding Access Key** (BAK) and calculates a SHA-256 hash of that key (**Binding Access Token** or BAT).
2.  Secret owner encrypts the secret (Keeper Record Key or Keeper Shared Folder Key) with BAK and sends the BAK 
    to the client (device or service that needs the secret)
3.  Secret owner calls the vault/application_share API passing the record or folder uid, encrypted secret and BAT.
    This gives the BAT owner the permission to access the secret.
4.  Upon reception of BAK, the client calls initializeStorage function, which calculates BAT by hashing the BAK 
    and initializes the key value storage with BAK and BAT.
5.  Client calls getSecrets function of the SDK.
6.  SDK generates private/public key pair and sends BAT and the public key to Keeper.
7.  Keeper verifies that the BAT does not have an associated public key yet and responds with an error if 
    the BAT has the associated public key, but the request is not signed.
8.  Keeper associated the BAT with the received public key, and responds with the secret and device token 
    (Keeper generated id of the client/device).
9.  The SDK uses the BAK to decrypt the record/folder key and stores the decrypted key in the key value storage.
10. The SDK stores the received device token to be used as an id in all subsequent calls.
11. The SDK decrypts the received secret using the record/folder key and returns the decrypted data to the client.
12. On the next call, the SDK uses the private key to sign the request and sends the device token instead of BAT to identify.
13. When Keeper receives a signed request it checks if the signature matches the associated public key and responds 
    with an error if the signature does not match.
14. When Keeper receives the request identified by device token instead of BAT, it erases the BAK encrypted secret from 
    the database to prevent the BAK from ever be reused.
    At this point, the binding is considered complete. The client is in control of the keys and can request the secret 
    again at any time if the sharing policy permits it.





